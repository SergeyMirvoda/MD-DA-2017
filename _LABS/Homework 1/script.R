# Работа с данными

# Загрузите данные в датафрейм, который назовите data.df
data.df <- read.table("http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat")
View(data.df)
# Сколько строк и столбцов в data.df? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы
paste("Загружено data.df, в котором ", nrow(data.df), " наблюдений и ", ncol(data.df), " переменных")

# Получите имена колонок из data.df
colnames(data.df)

# Найдите значение из 5 строки седьмого столбца
data.df[5, 7]

# Напечатайте целиком 2 строку из data.df
data.df[2,]
names(data.df)
# Объясните, что делает следующая строка кода names(data.df) <- c("year", "month", "day", seq(0,23))
# данная строка изменяет название колонок
names(data.df) <- c("year", "month", "day", seq(0, 23))
# Воспользуйтесь функциями head и tail, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
tail(data.df)
# последние 24 колонки показывают количество осадков по часам

# Добавьте новую колонку с названием daily, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?
data.df$daily <- rowSums(data.df[, 4:27])
hist(data.df[, 28])
# В данных присутствует ошибка (выбросы)

# Создайте новый датафрейм fixed.df в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна
fixed.df <- data.df
fixed.df$daily[which(fixed.df$daily < 0)] = 0
hist(fixed.df[, 28])
# на новой гистограмме отсутствуют некорректные (отрицательные) значения количества осадков

# Синтаксис и типизирование

# Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна
v <- c("4", "8", "15", "16", "23", "42") #вектору присваиваются символы, а не числа, соответсвенно дальнейшие действия будут произведены с кодами соответствующих символов
max(v)
sort(v)
sum(as.integer(v)) # посчитать сумму от символов невозможно
# Исправить проблему можно 2 способами: либо присвоить вектору числа, либо рассматривать каждый элемент вектора как число

# Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна
v2 <- c("5", 7, 12)
as.integer(v2[2]) + as.integer(v2[3])
# Все элементы вектора должны быть одного типа, поэтому в данном случае они инициализируются как *char*, а значит арифметические операции неприменимы
df3 <- data.frame(z1 = "5", z2 = 7, z3 = 12)
df3[1, 2] + df3[1, 3]
# С dataframe и list дела обстоят иначе: элементы разных типов можно встретить в пределах одного фрейма
l4 <- list(z1 = "6", z2 = 42, z3 = "49", z4 = 126)
l4[[2]] + l4[[4]]
as.integer(l4[2]) + as.integer(l4[4])
# в списках адресация [] - выводит список элементов по индексу, а [[]] - сам элемент

# Работа с функциями и операторами

# выведите на экран:
# Числа от 1 до 10000 с инкрементом 372.
seq(from = 1, to = 10000, by = 372)
# Числа от 1 до 10000 длиной 50.
seq(from = 1, to = 10000, length.out = 50)

# Объясните разницу между rep(1:5,times=3) и rep(1:5, each=3)
rep(1:5, times = 3)
rep(1:5, each = 3)
# первый вариант повторяет всю последовательность 3 раза, а второй - повторяет каждый элемент последовательности