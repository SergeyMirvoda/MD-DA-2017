points(c(35, 40, 21, 21.4),predicted, col = "red" )
summary(fit)
temp <- c(28.2, 21.4, 32.9, 24.0)
money <- c(44, 23, 43, 30)
data <- data.frame(temp,money)
plot(temp,money, xlim = c(0,50),ylim = c(0,60))
abline(fit)
new_data <- data.frame(temp=c(35, 40, 21, 21.4))
predicted <- predict(fit, newdata=new_data)
points(c(35, 40, 21, 21.4),predicted, col = "red" )
-14.085 * 35 + 1.843
fit$coefficients
fit$coefficients[2, 4]
coef(fit)
- 1.843 / -14.085
solve(1.843, -14.085)
solve(1.843, 14.085)
predicted
1.843 * 35 - 14.085
temp <- c(28.2, 21.4, 32.9, 24.0)
money <- c(44, 23, 43, 30)
data <- data.frame(temp,money)
plot(temp,money, xlim = c(0,50),ylim = c(0,60))
fit <- glm(money~temp, data)
fit <- glm(money~temp, data,poisson(link = "log"))
fit <- glm(money~temp, data,family = poisson(link = "log"))
plot(fit)
plot(fit)
plot(temp,money, xlim = c(0,50),ylim = c(0,60))
abline(fit)
fit <- lm(money~temp, data,family = poisson(link = "log"))
plot(fit)
fit <- lm(money~temp, data)
abline(fit)
plot(temp,money, xlim = c(0,50),ylim = c(0,60))
abline(fit)
fit <- lm(money~temp, data)
plot(fit)
summary(fit)
new_data <- data.frame(temp=c(24))
predicted <- predict(fit, newdata=new_data)
predicted
?lm
points(temp, 2.7 * temp – 35 , col = "red" )
2.7 * temp – 35
2.7* temp-35
points(temp, 2.7* temp-35, col = "red" )
abline(-35, 2.7, col="green")
?rlm
rfit <- rlm(money~temp, data)
rfit <- rlm(money~temp, data, method = c("M", "MM", "model.frame"))
rfit <- rlm(money~temp, data, method = c("M"))
?mad
rfit <- rlm(money~temp, data, scale.est = c("MAD"))
?lm
rfit <- rlm(money~temp, data, scale.est = c("MAD"),method = c("M", "MM"))
rfit <- rlm(money~temp, data, scale.est = c("MAD"),method = c("M", "MM"))
rfit <- rlm(money~temp, data, scale.est = c("MAD"), method = c("M"))
rfit <- rlm(money~temp, data, scale.est = c("MAD"), method = c("MM"))
summary(rfit)
temp <- c(28.2, 21.4, 32.9, 24.0)
money <- c(44, 23, 43, 30)
data <- data.frame(temp,money)
plot(temp,money, xlim = c(0,50),ylim = c(0,60))
fit <- lm(money~temp, data)
summary(fit)
2.7/1.8436
14 * 1.464
predicted <- predict(fit, newdata=new_data)
predicted
temp <- c(28.2, 21.4, 32.9, 24.0)
money <- c(44, 23, 43, 30)
fit <- lm(money~temp, data)
rfit <- rlm(money~temp, data, scale.est = c("MAD"))
plot(fit)
plot(temp,money, xlim = c(0,50),ylim = c(0,60))
abline(fit)
new_data <- data.frame(temp=c(30.7))
predicted <- predict(fit, newdata=new_data)
predicted
summary(fit)
grid()
plot(fit)
plot(faithful$waiting, eruption.stdres,
+     ylab="Standardized Residuals",
+     xlab="Waiting Time",
+     main="Old Faithful Eruptions")
plot(faithful$waiting, eruption.stdres,
ylab="Standardized Residuals",
xlab="Waiting Time",
main="Old Faithful Eruptions")
?rstandard
?OlsonNames
install.packages("ols")
install.packages("xxxxxxs")
install.packages("Design")
library(Design)
install.packages("rms")
install.packages("rms")
library(rms)
?ols
library(survival)
library(KMsurv)
data(package='KMsurv')
install.packages("KMsurv")
library(survival)
library(KMsurv)
data(package='KMsurv')
?cor
?pcor
library(ggm)
install.packages("ggm")
library(ggm)
?pcor
install.packages(c('xts','Defaults','quantmod','cairoDevice','RGtk2'))
library(quantmod)
library(cairoDevice)
library(quantmod)
library(cairoDevice)
library(RGtk2)
library(quantmod)
library(cairoDevice)
library(RGtk2)
pixmap <- gdkPixmapNew(w=500, h=500, depth=24)
asCairoDevice(pixmap)
getSymbols(c(sym))
sym <- 'MSFT'
getSymbols(c(sym))
chartSeries(get(sym), name=sym, theme="white", TA="addVo();addBBands();addCCI()")
plot_pixbuf <- gdkPixbufGetFromDrawable(NULL, pixmap,
pixmap$getColormap(),0, 0, 0, 0, 500, 500)
buffer <- gdkPixbufSaveToBufferv(plot_pixbuf, "jpeg", character(0), character(0))$buffer
?png
write(buffer, "test.jpeg")
chartSeries(get(sym), name=sym, theme="white", TA="addVo();addBBands();addCCI()")
getSymbols("YHOO")
chartSeries(YHOO)
plot(MSFT)
chartSeries(YHOO)
getSymbols("YHOO")
View(YHOO)
chartSeries(YHOO)
chartSeries(YHOO, subset='last 4 months')
chartSeries(YHOO, subset='2007::2008-01')
chartSeries(YHOO,theme=chartTheme('white'))
chartSeries(YHOO,TA=NULL)   #no volume
chartSeries(YHOO,TA=c(addVo(),addBBands()))
x <- chartSeries(YHOO,TA=c(addVo(),addBBands()))
x <- chartSeries(YHOO,TA=c(addVo(),addBBands()))
plot(1:5)
plot(1:5)
getSymbols("YHOO")
chartSeries(YHOO)
library(quantmod)
getSymbols("YHOO")
chartSeries(YHOO)
chartSeries(YHOO, subset='last 4 months')
chartSeries(YHOO, subset='2007::2008-01')
chartSeries(YHOO,theme=chartTheme('white'))
chartSeries(YHOO,TA=NULL)   #no volume
x=runif(10000,0,0.5)
y=runif(10000,0,3)
t=y<3*exp(-3*x)
u=x[t]
v=y[t]
plot(u,v)
i=0.5*3*length(u)/10000
0.5*3*length(u)/10000
plot(runif(100, min = -10, max = 10))
plot(rnorm(100, mean = 2, sd = 5))
plot(rnorm(100, mean = 2, sd = 5))
plot(runif(100, min = -10, max = 10))
plot(rnorm(100, mean = 2, sd = 5))
plot(rnorm(10000, mean = 2, sd = 5))
hist(rnorm(10000, mean = 2, sd = 5))
hist(runif(100, min = -10, max = 10))
hist(runif(10000, min = -10, max = 10))
hist(rnorm(10000, mean = 2, sd = 5))
data()
url = "https://raw.githubusercontent.com/SergeyMirvoda/da2016/master/lab6/wtid-report.csv"
data.df <- read.csv(url)
data.1 <- data.df[,c("Year", "P99.income.threshold", "P99.5.income.threshold","P99.9.income.threshold")]
data.1[data.1$Year == 1974,]$P99.income.threshold
plot(data.1$Year, data.1$P99.9.income.threshold, col = "green", type = "l",
xlim =c(min(data.1$Year),max(data.1$Year)),
ylim =c(min(c(data.1$P99.9.income.threshold,data.1$P99.5.income.threshold,data.1$P99.income.threshold)),
max(c(data.1$P99.9.income.threshold,data.1$P99.5.income.threshold,data.1$P99.income.threshold)))
)
lines(data.1$Year, data.1$P99.5.income.threshold, col = "red")
lines(data.1$Year, data.1$P99.income.threshold, col = "blue")
exponent.est_ratio <- function(p99, p99.9){
a<- 1 - log(10)/log(p99/p99.9)
return(a)
}
exponent.est_ratio(1e6,1e7)
x <- c(3.7, 2.7, 3.3, 1.3, 2.2, 3.1)
n = length(x)
plot((1:n - 1)/(n - 1), sort(x), type="l",
main = "Quantiles for the NYC Rain Data",
xlab = "Sample Fraction",
ylab = "Sample Quantile")
exponent.f <- function(p99.5, p99.9, a){
res <- (p99.5/p99.9)^-a+1
return (res)
}
exponent.f <- function(p99.5, p99.9, a){
res <- (p99.5/p99.9)^-a+1
return (res)
}
plot(data.1, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
plot(data.1$Year, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
abline(0,5)
abline(0,5)
abline(5,0)
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
exponent.f(1,1,1)
exponent.f <- function(p99.5, p99.9, a){
res <- (p99.5/p99.9)^(-a+1)
return (res)
}
exponent.f(1,1,1)
data.1
log(10)
lg(10)
log10(10)
exponent.est_ratio(1e6,1e7)
plot(data.1$Year, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
View(data.1)
url = "https://raw.githubusercontent.com/SergeyMirvoda/da2016/master/lab6/wtid-report.csv"
data.df <- read.csv(url)
View(data.df)
View(data.df)
plot(data.1$Year, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
abline(0,5)
abline(0,5)
abline(5,0)
abline(5,0,col = 'red')
abline(5,0,col = 'red')
exponent.f1 <- function(p99, p99.9, a){
res <- (p99/p99.9)^(-a+1)
return (res)
}
plot(data.1$Year, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold)))
plot(data.1$Year, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
exponent.f1 <- function(p99, p99.9, a){
res <- (p99/p99.9)^(-a+1)
return (res)
}
plot(data.1$Year, exponent.f(data.1$P99.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
abline(5,0,col = 'red')
plot(data.1$Year, exponent.f(data.1$P99.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold)))
abline(5,0,col = 'red')
exponent.f <- function(p99.5, p99.9, a){
res <- (p99.5/p99.9)^(-a+1)
return (res)
}
plot(data.1$Year, exponent.f(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold)))
abline(5,0,col = 'red')
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
abline(5,0)
exponent.est_ratio1 <- function(p99, p99.9){
a<- 1 - log(10)/log(p99.5/p99.9)
return(a)
}
plot(data.1$Year, exponent.est_ratio1(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
exponent.est_ratio1 <- function(p99, p99.9){
a<- 1 - log(10)/log(p99/p99.9)
return(a)
}
exponent.est_ratio <- function(p1, p2){
a<- 1 - log(10)/log(p1/p2)
return(a)
}
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
plot(data.1$Year, exponent.est_ratio(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold))
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
points(data.1$Year, exponent.est_ratio(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold),col= 'red')
plot(data.1$Year, exponent.est_ratio(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold),col= 'red')
points(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
data.1 <- data.df[,c("Year", "P99.income.threshold", "P99.income.threshold", "P99.5.income.threshold","P99.9.income.threshold")]
plot(data.1$Year, exponent.est_ratio(data.1$P90.income.threshold,data.1$P99.9.income.threshold),col= 'red')
data.1$Year
data.1$P90.income.threshold
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
points(data.1$Year, exponent.est_ratio(data.1$P99.5.income.threshold,data.1$P99.9.income.threshold),col= 'red')
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold))
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold),ylim = c(1910,2015) )
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold),xlim = c(1910,2015))
plot(data.1$Year, exponent.est_ratio(data.1$P99.income.threshold,data.1$P99.9.income.threshold),xlim = c(1930,1945))
library(lpSolveAPI)
cutoff_kinds_count <- 4
part_kinds <-c('A','B')
lpm <- make.lp(0, cutoff_kinds_count)
set.objfn(lpm, c(1,1,1,1)) #Минимизируем x1+x2+x3+x4
set.type(lpm,c(1,2,3,4),"integer")
add.constraint(lpm, c(3, 2, 1, 0), ">=", 800)
add.constraint(lpm, c(1, 6, 9, 13), ">=", 400)
solve(lpm)
#lp.control(lpmodel,sense='max')
get.objective(lpm)
get.variables(lpm)
?aov
library(multcomp)
attach(cholesterol)
table(trt)
trt
nrow(trt)
ncol(trt)
class(trt)
table(trt)
class(cholesterol)
nrow(cholesterol)
ncol(cholesterol)
cholesterol
cholesterol
aggregate(response,by = list(trt), FUN=mean)
aggregate(response,by = list(trt), FUN=sd)
fit <- aov(response ~ trt)
fit
summary(fit)
library(gplots)
install.packages("gplots")
library(gplots)
plotmeans(response ~ trt)
plotmeans(response ~ trt)
plotmeans(response ~ trt,xlab = 'Лечение', ylab = 'Эффект')
plotmeans(response ~ trt,xlab = 'Лечение', ylab = 'Эффект', main='Средние занчения')
aggregate(response,by = list(trt), FUN=mean)
aov
aov
?anova
library(readr)
dataset <- read_delim("~/ColibriStat/corr_data.csv",
";", escape_double = FALSE, trim_ws = TRUE)
View(dataset)
data <- read.csv("~/ColibriStat/corr_data.csv",sep = ";",header = TRUE)
View(data)
?cor
data$Revenue
View(data)
View(data)
cor(data$Temperature, data$Revenue)
cor(data$Number.of.children.who.walked.by, data$Revenue)
data <- read.csv("~/ColibriStat/corr_data.csv",sep = ";",header = TRUE)
cor(data$Number.of.children.who.walked.by, data$Revenue)
cor(data$Temperature, data$Revenue)
attach(data)
lm(Revenue ~ Temperature)
abline(lm)
fit <- lm(Revenue ~ Temperature)
abline(fit)
abline(fit)
abline(fit)
plot(fit)
plot(coef(fit))
plot(data)
plot(Revenue ~ Temperature)
attr(coef(fit))
coef(fit)
coef(fit)[1]
abline(coef(fit)[1], coef(fit)[2])
coef(fit)
abline(coef(fit)$Temperature, coef(fit)[2])
abline(coef(fit).Temperature, coef(fit)[2])
abline(coef(fit)[Temperature], coef(fit)[2])
abline(coef(fit)[Temperature], coef(fit)[2], col=red)
abline(coef(fit)[Temperature], coef(fit)[2], col='red')
abline(coef(fit)[[Temperature]]], coef(fit)[2], col='red')
abline(coef(fit)[[Temperature]], coef(fit)[2], col='red')
coef(fit)[[Temperature]]
summary(fit)
summary(fit)$Temperature
summary(fit)[1]
summary(fit)$coefficient
summary(fit)$coefficient$Temperature
summary(fit)$coefficient
summary(fit)$coefficient["Temperature"]
coef(fit)["Temperature"]
plot(Revenue ~ Temperature) #Построим график для имеющихся данных
result <- lm(Revenue ~ Temperature) #Посчитаем регессию при помощи линейной модели
result.coefs <- coef(fit) #Извелчём информацию о коэффициентах и сохраним её в переменную
result.coefs <- coef(result) #Извелчём информацию о коэффициентах и сохраним её в переменную
result.coefs["Temperature"]
result.coefs["(Intercept)"]
abline(result.coefs["Temperature"], result.coefs["(Intercept)"], col='red')
abline(result.coefs["Temperature"], result.coefs["(Intercept)"], col='red')
abline(result.coefs["(Intercept)"],result.coefs["Temperature"], col='red')
coef(result)
summary(result)
summarySE <- function(data=NULL, measurevar, groupvars=NULL, na.rm=FALSE,
conf.interval=.95, .drop=TRUE) {
library(plyr)
# New version of length which can handle NA's: if na.rm==T, don't count them
length2 <- function (x, na.rm=FALSE) {
if (na.rm) sum(!is.na(x))
else       length(x)
}
# This does the summary. For each group's data frame, return a vector with
# N, mean, and sd
datac <- ddply(data, groupvars, .drop=.drop,
.fun = function(xx, col) {
c(N    = length2(xx[[col]], na.rm=na.rm),
mean = mean   (xx[[col]], na.rm=na.rm),
sd   = sd     (xx[[col]], na.rm=na.rm)
)
},
measurevar
)
# Rename the "mean" column
datac <- rename(datac, c("mean" = measurevar))
datac$se <- datac$sd / sqrt(datac$N)  # Calculate standard error of the mean
# Confidence interval multiplier for standard error
# Calculate t-statistic for confidence interval:
# e.g., if conf.interval is .95, use .975 (above/below), and use df=N-1
ciMult <- qt(conf.interval/2 + .5, datac$N-1)
datac$ci <- datac$se * ciMult
return(datac)
}
library(ggplot2)
library(reshape)
default <- c(94399, 99204, 93377, 95599, 92807) / 1000
patched <- c(64445, 55687, 56821, 60923, 60836) / 1000
(mean(patched) - mean(default))/ mean(default)
#тест
test <- t.test(default, patched,paired = TRUE)
test$p.value
test$statistic
test$parameter
#график
#select
id <- seq(1, 5)
mode <- replicate(5, "select")
df <- data.frame(id, default, patched, mode)
df
data_s <- melt(df, id=c("id","mode"))
colnames(data_s) <- c("id","mode", "version", "time")
#insert
default <- c(67502, 67776, 71069, 66859, 71232) / 1000
patched <- c(77879, 77047, 75323, 73654, 74323) / 1000
mean(default)
mean(patched)
sd(default)
sd(patched)
(mean(patched) - mean(default))/ mean(default)
id <- seq(21, 25)
mode <- replicate(5, "insert")
df <- data.frame(id, default, patched, mode)
df
data_i <- melt(df, id=c("id","mode"))
colnames(data_i) <- c("id","mode", "version", "time")
data<-rbind(data_s, data_i)
dataStats <- summarySE(data, measurevar="time", groupvars=c("version", "mode")) #функция ниже
dataStats$version <- factor(dataStats$version)
dataStats$operation <- factor(dataStats$operation)
ggplot(dataStats, aes(x=mode, y=time, fill=version)) +
geom_bar(position=position_dodge(), stat="identity",
colour="black", # Use black outlines,
size=.3) +      # Thinner lines
geom_errorbar(aes(ymin=time-se, ymax=time+se),
size=.3,    # Thinner lines
width=.2,
position=position_dodge(.9)) +
xlab("Patched vs not patched") +
ylab("Time (s)") +
scale_fill_hue(name="Source code version", #
breaks=c("default", "patched"),
labels=c("Default", "Patched")) +
ggtitle("The Effect of improving penalty function \n on SELECT/INSERT query performance ") +
theme_bw()
setwd("C:/lessons/MD-DA-2017")
table(diet$diet.type, diet$weight.loss)
data = read.csv("data/diet.csv",row.names=1)
summary(data)
colnames(data) <- c("gender", "age", "height", "initial.weight",
"diet.type", "final.weight")
data$diet.type <- factor(c("A", "B", "C")[data$diet.type])
summary(data)
data$diet.type <- factor(c("A", "B", "C")[data$diet.type])
data$weight.loss = data$initial.weight - data$final.weight
boxplot(weight.loss~diet.type,data=data,col="light gray",
ylab = "Weight loss (kg)", xlab = "Diet type")
table(data$diet.type, data$weight.loss)
table(data$weight.loss, data$diet.type)
table(data$diet.type)
fit <- aov(weight.loss ~ diet.type, data=data)
summary(fit)
library(gplots)
plotmeans(weight.loss ~ diet.type, data=data)
aggregate(weight.loss, by = diet.type, data=data, FUN=sd)
aggregate(data$weight.loss, by = data$diet.type, FUN=sd)
aggregate(data$weight.loss, by = list(data$diet.type), FUN=sd)
TukeyHSD(fit)
table(data$diet.type)
table(data$diet.type)
library(gplots) #библиотека устанавлевается с помощью install.packages
plotmeans(weight.loss ~ diet.type, data=data)
aggregate(data$weight.loss, by = list(data$diet.type), FUN=sd)
fit <- aov(weight.loss ~ diet.type, data=data)
summary(fit)
fit <- aov(weight.loss ~ diet.type, data=data)
summary(fit)
TukeyHSD(fit)
TukeyHSD(fit)
TBD
library(multcomp)
par(mar=c(5,4,6,2))
tuk <- glht(fit, linfct=mcp(trt="Tukey"))
plot(cld(tuk, level=.05),col="lightgrey")
tuk <- glht(fit, linfct=mcp(trt="Tukey"))
tuk <- glht(fit, linfct=mcp(tension="Tukey"))
tuk <- glht(fit, linfct=mcp(diet.type="Tukey"))
plot(cld(tuk, level=.05),col="lightgrey")
